<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rhaeguard&#39;s stuff</title>
    <link>https://rhaeguard.github.io/</link>
    <description>Recent content on rhaeguard&#39;s stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Aug 2022 21:30:04 +0800</lastBuildDate><atom:link href="https://rhaeguard.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Thoughts on Software Development Pratices</title>
      <link>https://rhaeguard.github.io/posts/thoughts-on-software-development-practices/</link>
      <pubDate>Tue, 16 Jul 2024 04:18:33 -0600</pubDate>
      
      <guid>https://rhaeguard.github.io/posts/thoughts-on-software-development-practices/</guid>
      <description>These are some of my random thoughts on software development pratices. These are not facts, these are opinions. I reckon you most likely have seen or heard some or all of these at some point.
Vertical scaling is probably fine for your use case, don&amp;rsquo;t be obsessed with horizontal scaling. The monolith is fine. Performance matters, and it matters much more than you think. Software security should not be an afterthought.</description>
    </item>
    
    <item>
      <title>Learning by association</title>
      <link>https://rhaeguard.github.io/posts/learning-by-association/</link>
      <pubDate>Tue, 16 Jul 2024 03:03:33 -0600</pubDate>
      
      <guid>https://rhaeguard.github.io/posts/learning-by-association/</guid>
      <description>I have a method/strategy that I use to remember things. It is called associative learning which is when one stimulus can trigger another one. Like the experiment Ivan Pavlov performed where the dog was conditioned to associate food with sound.
My method is not necessarily conditioning oneself to remember things, but more about remembering things together. This method can be useful in long-term activities such as learning a new language. It can also be useful in everyday scenarios.</description>
    </item>
    
    <item>
      <title>How to parse JSON using shift-reduce parsing approach</title>
      <link>https://rhaeguard.github.io/posts/json-parsing-shift-reduce/</link>
      <pubDate>Thu, 09 Nov 2023 01:12:33 -0600</pubDate>
      
      <guid>https://rhaeguard.github.io/posts/json-parsing-shift-reduce/</guid>
      <description>Parsing JSON is something that the majority of programmers have done. Almost all languages have means to deserialize (unmarshall) JSON from text into some data structure. In this article, we are going to try doing exactly that.
Grammar Just like in natural languages, the programming languages and various data formats have a grammar. The grammar consists of rules that show how the text input needs to be structured. For JSON the following is a simplified version of a part of the grammar:</description>
    </item>
    
    <item>
      <title>How to build a regex engine from scratch</title>
      <link>https://rhaeguard.github.io/posts/regex/</link>
      <pubDate>Sat, 07 Oct 2023 01:40:33 -0600</pubDate>
      
      <guid>https://rhaeguard.github.io/posts/regex/</guid>
      <description>In this article, we&amp;rsquo;ll build a simple regular expression engine that will be able to use [a-zA-Z][a-zA-Z0-9_.]+@[a-zA-Z0-9]+.[a-zA-Z]{2,} pattern (. is used as literal instead of any character) to check for the validity of email addresses. We will use Golang. The article is divided into 3 sections:
Parsing Building the state machine Matching Parsing On its own, a regex string is just that &amp;mdash; a string. We need to transform it into something that has a structure.</description>
    </item>
    
  </channel>
</rss>
