<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="In this article, we&rsquo;ll build a simple regular expression engine that will be able to use [a-zA-Z0–9_]&#43;@[a-zA-Z0–9]&#43;.[a-zA-Z]{2,} pattern to check for the validity of email addresses. We will use Golang. The article is divided into 3 sections:
Parsing Building the epsilon-NFA Matching Parsing On its own, a regex string is just that - a string. We need to convert that input into something has a structure. For instance:
# original regex string [a-zA-Z0–9_]&#43;@[a-zA-Z0–9]&#43;.">  

  <title>
    
      [WIP] How to build a regex engine from scratch
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/unfunction/" />
  
  
  
  <link rel="stylesheet" href="/unfunction/css/main.f258e387d11b0cbe3f30b888037616e7cceab80a2aa00830820dff82be83d2f39508afca0e411c8827565d13425f067c8477550586cd27cf07c72a24d395e08b.css" integrity="sha512-8ljjh9EbDL4/MLiIA3YW58zquAoqoAgwgg3/gr6D0vOVCK/KDkEciCdWXRNCXwZ8hHdVBYbNJ88Hxyok05Xgiw==" />
  
</head>
<body a="light">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/unfunction/">home</a>
<button class="theme-switch">dark</button>


<article>
    <p class="post-meta">
        <time datetime="2023-09-28 22:40:33 -0600 -0600">
            2023-09-28
        </time>
    </p>

    <h1>[WIP] How to build a regex engine from scratch</h1>

    

    <p>In this article, we&rsquo;ll build a simple regular expression engine that will be able to use <code>[a-zA-Z0–9_]+@[a-zA-Z0–9]+.[a-zA-Z]{2,}</code> pattern to check for the validity of email addresses. We will use Golang. The article is divided into 3 sections:</p>
<ul>
<li><a href="#parsing">Parsing</a></li>
<li><a href="#building-the-epsilon-nfa">Building the epsilon-NFA</a></li>
<li><a href="#matching">Matching</a></li>
</ul>
<h2 id="parsing">Parsing</h2>
<p>On its own, a regex string is just that - a string. We need to convert that input into something has a structure. For instance:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># original regex string</span>
</span></span><span style="display:flex;"><span>[a<span style="color:#f92672">-</span>zA<span style="color:#f92672">-</span>Z0<span style="color:#960050;background-color:#1e0010">–</span><span style="color:#ae81ff">9</span>_]<span style="color:#f92672">+@</span>[a<span style="color:#f92672">-</span>zA<span style="color:#f92672">-</span>Z0<span style="color:#960050;background-color:#1e0010">–</span><span style="color:#ae81ff">9</span>]<span style="color:#f92672">+.</span>[a<span style="color:#f92672">-</span>zA<span style="color:#f92672">-</span>Z]{<span style="color:#ae81ff">2</span>,}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># regex tokens</span>
</span></span><span style="display:flex;"><span>Repeat(<span style="color:#ae81ff">1</span>, infinity):
</span></span><span style="display:flex;"><span>   Range(a, b,<span style="color:#f92672">...</span>z, A, B,<span style="color:#f92672">...</span>,Z, <span style="color:#ae81ff">0</span>,<span style="color:#f92672">...</span>,<span style="color:#ae81ff">9</span>,_)
</span></span><span style="display:flex;"><span>Literal(<span style="color:#f92672">@</span>)
</span></span><span style="display:flex;"><span>Repeat(<span style="color:#ae81ff">1</span>, infinity):
</span></span><span style="display:flex;"><span>   Range(a, b,<span style="color:#f92672">...</span>z, A, B,<span style="color:#f92672">...</span>,Z, <span style="color:#ae81ff">0</span>,<span style="color:#f92672">...</span>,<span style="color:#ae81ff">9</span>)
</span></span><span style="display:flex;"><span>Literal(<span style="color:#f92672">.</span>)
</span></span><span style="display:flex;"><span>Repeat(<span style="color:#ae81ff">2</span>, infinity):
</span></span><span style="display:flex;"><span>   Range(a, b,<span style="color:#f92672">...</span>z, A, B,<span style="color:#f92672">...</span>,Z)
</span></span></code></pre></div><p>In this section, we&rsquo;ll go over the process of parsing a regex string into tokens. 
The core idea when it comes to parsing regex is simple, we will look for the characters that have special meanings such as <code>* + ? () [] {}</code> etc. and will try to create tokens out of those. It&rsquo;ll be more clear once we start writing some code.
Before getting into the parsing algorithm, let&rsquo;s define some types and constants.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">tokenType</span> <span style="color:#66d9ef">uint8</span> <span style="color:#75715e">// &lt;1&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> ( <span style="color:#75715e">// &lt;2&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">group</span>           <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">bracket</span>         <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">or</span>              <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">repeat</span>          <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">literal</span>         <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">groupUncaptured</span> <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">token</span> <span style="color:#66d9ef">struct</span> { <span style="color:#75715e">// &lt;3&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">tokenType</span> <span style="color:#a6e22e">tokenType</span>
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">// the payload required for each token will be different 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// so we need to be flexible with the type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">value</span>     <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">parseContext</span> <span style="color:#66d9ef">struct</span> { <span style="color:#75715e">// &lt;4&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// the index of the character we&#39;re processing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">// in the regex string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#a6e22e">pos</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">tokens</span> []<span style="color:#a6e22e">token</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>it&rsquo;s just a type alias for the character type</li>
<li>constants for specifying the type of the token we are working with</li>
<li>the main token struct, it has a <em>type</em> and a <em>value</em> which can be anything depending on the given type</li>
<li><code>parseContext</code> will help us keep track of our positions and will hold the tokens parsed so far</li>
</ol>
<p>Now, next is our parsing algorithm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">regex</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">parseContext</span>{
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">pos</span>:    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">tokens</span>: []<span style="color:#a6e22e">token</span>{},
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span> &lt; len(<span style="color:#a6e22e">regex</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">process</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ctx</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The basic idea is that we loop through each character and process it until we reach to the end of the regex string. Next, let&rsquo;s take a look at the <code>process</code> method. It&rsquo;s a bit more involved, so let&rsquo;s take it step by step.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">process</span>(<span style="color:#a6e22e">regex</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span> { <span style="color:#75715e">// &lt;1&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">groupCtx</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">parseContext</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">pos</span>:    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">tokens</span>: []<span style="color:#a6e22e">token</span>{},
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">parseGroup</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">groupCtx</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span> = append(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>, <span style="color:#a6e22e">token</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">group</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">groupCtx</span>.<span style="color:#a6e22e">tokens</span>,
</span></span><span style="display:flex;"><span>		})
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;[&#39;</span> { <span style="color:#75715e">// &lt;2&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">parseBracket</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;|&#39;</span> { <span style="color:#75715e">// &lt;3&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">parseOr</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;?&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;+&#39;</span> { <span style="color:#75715e">// &lt;4&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">parseRepeat</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;{&#39;</span> { <span style="color:#75715e">// &lt;5&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">parseRepeatSpecified</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// &lt;6&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">token</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">literal</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">ch</span>,
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span> = append(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>, <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As we mentioned earlier, we try to match the characters we recognize and use them to parse tokens.</p>
<ol>
<li>if the current character is <code>(</code> - the opening parenthesis, we know that it needs to be a regex group, thus we try to parse the next couple of characters expecting a string of characters that corresponds to a regex group.</li>
<li>if it&rsquo;s <code>[</code> - the opening bracket, we know that it&rsquo;s a bracket expression, so we proceed accordingly</li>
<li>if the character is a vertical pipe - <code>|</code>, that&rsquo;s an Or expression (alternative).</li>
<li>the characters <code>*</code>, <code>+</code> and <code>?</code> all represent repetition. I know that <code>?</code> means optional, but in terms of repetition, it simply means that the character repeats at most once.</li>
<li>curly braces specify repetition as well. In fact, the previous repetition options can all be specified using braces:
<ul>
<li><code>a* == a{0,}</code></li>
<li><code>a+ == a{1,}</code></li>
<li><code>a? == a{0,1}</code></li>
</ul>
</li>
<li>if the character did not match with anything, we consider it as a literal. Please keep in mind that this is a simplified implementation. There are a lot of cases to consider when it comes to parsing regular expressions; for instance, 1 is a literal, but depending on the context it can actually be a part of a backreference <code>\1</code> that refers to the first captured group. Our simplified algorithm also DOES NOT consider the escape characters (which means <code>\a</code> is considered as a concatenation of two literals: <code>\</code> and <code>a</code>).</li>
</ol>
<p>Next, we&rsquo;ll examine each of the functions defined in the above snippet. Let&rsquo;s start with the parsing of group expressions <strong><em>(1)</em></strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parseGroup</span>(<span style="color:#a6e22e">regex</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">// get past the LPAREN (
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;)&#39;</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">process</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We process each character like we did in the parse method until we encounter the closing parenthesis. We will not cover the error handling in this tutorial, so we&rsquo;re simply not checking if the index is still within bounds. It will panic anyway. But what about the extra code around <code>parseGroup</code> in the <code>process</code> function? What happens there? Here&rsquo;s the snippet:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// snippet from the `process` function
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">groupCtx</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">parseContext</span>{
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">pos</span>:    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">tokens</span>: []<span style="color:#a6e22e">token</span>{},
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// parsing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">parseGroup</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">groupCtx</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span> = append(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>, <span style="color:#a6e22e">token</span>{
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">group</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">groupCtx</span>.<span style="color:#a6e22e">tokens</span>,
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>We create a new context specific to each group, so that we&rsquo;ll be able to bundle together all the tokens within a specific group without dealing with the top level context object. </p>
<p>Let&rsquo;s now see how we can parse bracket expressions <strong><em>(2)</em></strong>. This is the whole function, but we&rsquo;ll cover it step by step.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parseBracket</span>(<span style="color:#a6e22e">regex</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span> <span style="color:#75715e">// get past the LBRACKET
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">literals</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;]&#39;</span> { <span style="color:#75715e">// &lt;1&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span> { <span style="color:#75715e">// &lt;2&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">prev</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">literals</span>[len(<span style="color:#a6e22e">literals</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>] <span style="color:#75715e">// &lt;2-1&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">literals</span>[len(<span style="color:#a6e22e">literals</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%c%c&#34;</span>, <span style="color:#a6e22e">prev</span>, <span style="color:#a6e22e">next</span>) <span style="color:#75715e">// &lt;2-2&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// &lt;3&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">literals</span> = append(<span style="color:#a6e22e">literals</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%c&#34;</span>, <span style="color:#a6e22e">ch</span>))
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span> <span style="color:#75715e">// &lt;4&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">literalsSet</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">uint8</span>]<span style="color:#66d9ef">bool</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">literals</span> { <span style="color:#75715e">// &lt;5&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">0</span>]; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">l</span>[len(<span style="color:#a6e22e">l</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#75715e">// &lt;6&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">literalsSet</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span> = append(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>, <span style="color:#a6e22e">token</span>{ <span style="color:#75715e">// &lt;7&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">bracket</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">literalsSet</span>,
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>Similarly to the way we parsed the group expression, we go through each character till we reach the closing bracket character (<code>]</code>).</li>
<li>For each character we check if it is <code>-</code> because that&rsquo;s the range indicator (e.g., <code>a-zK-Z2-8</code>).
<ol>
<li>When it is indeed the range indicator, we take the next character from the regex string, and the previous character from the list of literals (<em>it&rsquo;s the last character in that list</em>).</li>
<li>Then we save it back to the list as 2 characters together. We could choose a different way of saving the parsed literals, but I find this to be simple and easy to understand.</li>
</ol>
</li>
<li>If it&rsquo;s not the range indicator we consider it a single literal, and save it to the list.</li>
<li>Move on to the next character</li>
<li><code>literals</code> list contains both literals and ranges. But those may contain duplicates. Consider the following regex: <code>[a-me-s]</code> . There&rsquo;s a clear overlap between the ranges. We go over the saved values and each literal to the <code>literalsSet</code>. By definition, sets do not contain duplicates, so that gets the job done. Since we&rsquo;re implementing this in Golang, we are using a map because there are no natively provided sets in Golang, and installing a library just for a set is unnecessary.</li>
<li>Add each character from the start till the end of the saved value.
<ol>
<li>In single literals, this will only add the literal itself</li>
<li>In ranges, it will add everything from the first character till the last character (inclusive).</li>
</ol>
</li>
<li>Finally, once we have all the duplicates removed, we save the bracket token to our list of tokens.</li>
</ol>
<p>Next in line is <code>parseOr</code> which is able to parse alternations <strong><em>(3)</em></strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parseOr</span>(<span style="color:#a6e22e">regex</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// &lt;1:start&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">rhsContext</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">parseContext</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">pos</span>:    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">tokens</span>: []<span style="color:#a6e22e">token</span>{},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rhsContext</span>.<span style="color:#a6e22e">pos</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">// get past |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">rhsContext</span>.<span style="color:#a6e22e">pos</span> &lt; len(<span style="color:#a6e22e">regex</span>) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">rhsContext</span>.<span style="color:#a6e22e">pos</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;)&#39;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">process</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">rhsContext</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">rhsContext</span>.<span style="color:#a6e22e">pos</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// &lt;1:end&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// both sides of the OR expression
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">token</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">groupUncaptured</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>, <span style="color:#75715e">// &lt;2&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">token</span>{ <span style="color:#75715e">// &lt;3&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">groupUncaptured</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">rhsContext</span>.<span style="color:#a6e22e">tokens</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span> = <span style="color:#a6e22e">rhsContext</span>.<span style="color:#a6e22e">pos</span> <span style="color:#75715e">// &lt;4&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span> = []<span style="color:#a6e22e">token</span>{{ <span style="color:#75715e">// &lt;5&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">or</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">value</span>:     []<span style="color:#a6e22e">token</span>{<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span>},
</span></span><span style="display:flex;"><span>	}}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>The alternation (<em>or</em>) operation has the following syntax: <code>&lt;left&gt;|&lt;right&gt;</code> or <code>(&lt;left&gt;|&lt;right&gt;)</code> meaning it is an alternation between what&rsquo;s in the left hand side and what&rsquo;s on the right hand side. By the time we encounter the <code>|</code> symbol, we&rsquo;ve already parsed everything to the left of it. Now, it&rsquo;s time to parse everything to the right. It&rsquo;s almost the same code as parsing groups.  We create a right-hand-side specific empty context, and collect all the tokens into it. We do this until the end of the regex string or until we face a closing parenthesis.</li>
<li>Now that we are done parsing both sides, it&rsquo;s time to create the alternation token. The left side will contain all the tokens that were in the original context object, because it contains all the tokens we have parsed so far.</li>
<li>For the right hand side, we take all the tokens collected into the <code>rhsContext</code> object. For both tokens, we use <code>groupUncaptured</code> as the type, it&rsquo;s simply a type created to denote a bundle of tokens.</li>
<li>We update the position of the original context.</li>
<li>We create the alternation token and add it to the original context. One important thing is that we do not keep the old tokens in the original context as they are already contained in the alternation token.</li>
</ol>
<p>Now let&rsquo;s look at repetitions <strong><em>(4)</em></strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parseRepeat</span>(<span style="color:#a6e22e">regex</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">min</span>, <span style="color:#a6e22e">max</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">min</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">max</span> = <span style="color:#a6e22e">repeatInfinity</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;?&#39;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">min</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">max</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// ch == &#39;+&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">min</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">max</span> = <span style="color:#a6e22e">repeatInfinity</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// we need to wrap the last token with the quantifier data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// so that we know what the min and max apply to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lastToken</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>[len(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>[len(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">token</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">repeat</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">value</span>: <span style="color:#a6e22e">repeatPayload</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">min</span>:   <span style="color:#a6e22e">min</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">max</span>:   <span style="color:#a6e22e">max</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">token</span>: <span style="color:#a6e22e">lastToken</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Basic idea for this particular method is that each symbol here specifies some minimum and maximum number of repetitions. <code>repeatInfinity</code> is <code>-1</code>, but we use it as infinity.</li>
<li>Once we have the boundaries set, we simply take  the last parsed token, wrap it in a <code>repeat</code> token and appropriate boundaries, and finally save it back to the same position in the tokens list.</li>
</ul>
<p>The other repetition expression has a bit longer code, but the idea is still the same <strong><em>(5)</em></strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parseRepeatSpecified</span>(<span style="color:#a6e22e">regex</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// +1 because we skip LCURLY { at the beginning
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// proceed until we reach to the end of the curly braces
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;}&#39;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">boundariesStr</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">start</span>:<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>] <span style="color:#75715e">// &lt;1&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">pieces</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">boundariesStr</span>, <span style="color:#e6db74">&#34;,&#34;</span>) <span style="color:#75715e">// &lt;2&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">min</span>, <span style="color:#a6e22e">max</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">pieces</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> { <span style="color:#75715e">// &lt;3&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">pieces</span>[<span style="color:#ae81ff">0</span>]); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			panic(<span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>())
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">min</span> = <span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">max</span> = <span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">pieces</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span> { <span style="color:#75715e">// &lt;4&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">pieces</span>[<span style="color:#ae81ff">0</span>]); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			panic(<span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>())
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">min</span> = <span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">pieces</span>[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">max</span> = <span style="color:#a6e22e">repeatInfinity</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">value</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">pieces</span>[<span style="color:#ae81ff">1</span>]); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			panic(<span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>())
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">max</span> = <span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;There must be either 1 or 2 values specified for the quantifier: provided &#39;%s&#39;&#34;</span>, <span style="color:#a6e22e">boundariesStr</span>))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// we need to wrap the last token with the quantifier data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// so that we know what the min and max apply to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// &lt;5&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lastToken</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>[len(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>[len(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">token</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">repeat</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">value</span>: <span style="color:#a6e22e">repeatPayload</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">min</span>:   <span style="color:#a6e22e">min</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">max</span>:   <span style="color:#a6e22e">max</span>,
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">token</span>: <span style="color:#a6e22e">lastToken</span>,
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li>We need to get the string expression for boundaries which is everything between the curly braces <code>{}</code>.</li>
<li>Next, we split that string into pieces separated by a comma <code>,</code></li>
<li>If there&rsquo;s only one element (e.g., <code>{1}</code>) that means the exact number of repeats, so <code>min</code> and <code>max</code> will be the same. The error handling syntax of Golang may make things look complicated, but it just means that if there&rsquo;s any error while converting a string into a integer, just panic and stop everything.</li>
<li>If there are two pieces, the first value is the min, and the second one is the max (e.g., <code>{3,7}</code>). However, there&rsquo;s a chance that the second value might be missing: <code>{3,}</code>. In this example, the token is required to repeat at least three times, but no upper bound is set which means it will be <code>repeatInfinity</code>. The error handling is the same as in <code>parseRepeat</code> function.</li>
<li>Now that we have the boundaries, we take  the last parsed token, wrap it in a <code>repeat</code> token and appropriate boundaries, and save it back to the same position in the tokens list.</li>
</ol>
<p>With this, we conclude the steps required for parsing a regex string. Next, we&rsquo;ll examine how we can build a state machine out of those tokens we&rsquo;ve parsed.</p>
<h2 id="building-the-epsilon-nfa">Building the epsilon-NFA</h2>
<h3 id="whats-an-nfa">What&rsquo;s an NFA?</h3>
<p>WIP</p>
<h3 id="regular-expression-to-epsilon-nfa">Regular expression to epsilon-NFA</h3>
<p>The previous step provides us with a list of tokens. We now need to convert these an epsilon-NFA. To achieve this, we will use an algorithm called Thompson&rsquo;s construction. We&rsquo;ll explain the algorithm with several visual examples and the corresponding code. But before we do that, let&rsquo;s go over the structure of the overall algorithm.</p>
<p>To represent an NFA state, we&rsquo;ll use this simple structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">state</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span>       <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">terminal</span>    <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">transitions</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">uint8</span>][]<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ol>
<li><code>start</code> indicates whether the state&rsquo;s the entrypoint or not.</li>
<li><code>terminal</code> indicates wheteher the state&rsquo;s the final state. Reaching this state means that the input matches with the regex.</li>
<li><code>transitions</code> is a map where a character maps to a list of different states.</li>
</ol>
<p>This is the high-level visualization of the algorithm:</p>
<p><img src="/unfunction/toNFA_explained.png" alt="Creating an NFA from regular expression, high level view"></p>
<ul>
<li>We will have a start (pink) and terminal (blue) states.</li>
<li>For each token, we&rsquo;ll create a separate NFA, and these NFAs will be concatenated with epsilon transitions. Last state of the previous NFA, will be connected to the first state of the next NFA, like this:</li>
</ul>
<p><img src="/unfunction/toNFA_concat.png" alt="Concatenation process"></p>
<ul>
<li>There will be an epsilon transition from the start state to the first state (s1) of the concatenated NFAs.</li>
<li>There will be an epsilon transition from the last state of the concatenated NFAs to the terminal state.</li>
</ul>
<p>Let&rsquo;s go over the same thing in code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">epsilonChar</span> <span style="color:#66d9ef">uint8</span> = <span style="color:#ae81ff">0</span> <span style="color:#75715e">// empty character
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">toNfa</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">state</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">startState</span>, <span style="color:#a6e22e">endState</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tokenToNfa</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>[<span style="color:#ae81ff">0</span>]) <span style="color:#75715e">// &lt;1&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#75715e">// &lt;2&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">startNext</span>, <span style="color:#a6e22e">endNext</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tokenToNfa</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>[<span style="color:#a6e22e">i</span>]) <span style="color:#75715e">// &lt;3&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">endState</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = append(<span style="color:#a6e22e">endState</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>], <span style="color:#a6e22e">startNext</span>) <span style="color:#75715e">// &lt;4&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">endState</span> = <span style="color:#a6e22e">endNext</span> <span style="color:#75715e">// &lt;5&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">state</span>{ <span style="color:#75715e">// &lt;6&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">transitions</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">uint8</span>][]<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>{
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">epsilonChar</span>: {<span style="color:#a6e22e">startState</span>},
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">start</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">state</span>{ <span style="color:#75715e">// 7
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">transitions</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">uint8</span>][]<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>{},
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">terminal</span>:    <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">endState</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = append(<span style="color:#a6e22e">endState</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>], <span style="color:#a6e22e">end</span>) <span style="color:#75715e">// &lt;8&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">start</span> <span style="color:#75715e">// &lt;9&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><ol>
<li>We take the first token, and convert that to an NFA. <code>tokenToNfa</code> function will be explained later. For now, just know that it creates an NFA from the given token, and returns the start and end states of this newly created NFA.</li>
<li>We go over the rest of tokens</li>
<li>We call <code>tokenToNfa</code> for each token and save the start and end states.</li>
<li>We link the end state from the previous <code>tokenToNfa</code> call to the start state of the new NFA.</li>
<li>Save the end state, because it will be useful in the next iteration</li>
<li>We create the previously mentioned start state. This state now has an epsilon transition to the start state of the very first NFA we created.</li>
<li>We create the terminal state.</li>
<li>The end state of the last NFA we created now has an epsilon transition to the terminal state.</li>
<li>Finally, we return the start state because that&rsquo;s the entrypoint.</li>
</ol>
<p>Now that we have an overall outline of what we&rsquo;re doing to construct our NFA, let&rsquo;s take a look at how each token is converted into an NFA.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// returns (start, end)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">tokenToNfa</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">token</span>) (<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>, <span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">state</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">transitions</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">uint8</span>][]<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>{},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">state</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">transitions</span>: <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">uint8</span>][]<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>{},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">tokenType</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">literal</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">or</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">bracket</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">group</span>, <span style="color:#a6e22e">groupUncaptured</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#a6e22e">repeat</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>		panic(<span style="color:#e6db74">&#34;unknown type of token&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">end</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>The code above is the skeleton of the <code>tokenToNfa</code> function, we&rsquo;ll go over each token type and how it is handled.</li>
<li>Overall, we create empty <code>start</code> and <code>end</code> states, perform some logic within switch statement, and return those variables.</li>
</ul>
<p>In the next couple of sections, we&rsquo;ll go over each token type, visualize the steps and finally show the code.</p>
<h4 id="literals">Literals</h4>
<p>Let&rsquo;s start with the literals as they are the simplest to explain.</p>
<p><img src="/unfunction/tokenToNfa_literal.png" alt="literal to nfa"></p>
<ul>
<li>In order to go from <code>start</code> to <code>end</code>, we need the transition <code>ch</code>. <code>ch</code> represents a single character.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">literal</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">value</span>.(<span style="color:#66d9ef">uint8</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">ch</span>] = []<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>{<span style="color:#a6e22e">end</span>}
</span></span></code></pre></div><ul>
<li>We can see the exact same thing in the code as well. <code>t.value</code> is referring to the value we saved in the <code>token</code> struct back when we were parsing the tokens.</li>
</ul>
<h4 id="oralternative">or/alternative</h4>
<p><img src="/unfunction/tokenToNfa_or.png" alt="or to nfa"></p>
<ul>
<li>Or means a choice between two different paths. Recall that in the parsing phase, the value for or token had <em>left</em> and <em>right</em> sides (shown in the diagram as well). Each of these tokens represent different NFAs.</li>
<li>To create the Or NFA, we need to have:
<ul>
<li>an epsilon transition from the start state to the starts of both left and right NFAs</li>
<li>an epsilon transition from the ends of both left and right NFAs to the end state.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">or</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">values</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">value</span>.([]<span style="color:#a6e22e">token</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">left</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">values</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">values</span>[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">s1</span>, <span style="color:#a6e22e">e1</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tokenToNfa</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">left</span>) <span style="color:#75715e">// &lt;1&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">s2</span>, <span style="color:#a6e22e">e2</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tokenToNfa</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">right</span>) <span style="color:#75715e">// &lt;1&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = []<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>{<span style="color:#a6e22e">s1</span>, <span style="color:#a6e22e">s2</span>} <span style="color:#75715e">// &lt;2&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">e1</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = []<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>{<span style="color:#a6e22e">end</span>} <span style="color:#75715e">// &lt;3&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">e2</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = []<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>{<span style="color:#a6e22e">end</span>} <span style="color:#75715e">// &lt;3&gt;
</span></span></span></code></pre></div><ol>
<li>Creating both left and right NFAs</li>
<li>Connecting the start state with the starts of both NFAs with an epsilon transition</li>
<li>Connecting the end states of each NFA with the end state of the Or NFA.</li>
</ol>
<h4 id="bracket-expression">Bracket expression</h4>
<p><img src="/unfunction/tokenToNfa_bracket.png" alt="bracket to nfa"></p>
<ul>
<li>We can think of bracket expressions as a big Or expressions. For example, <code>[a-c0-2x]</code> means <code>a|b|c|0|1|2|x</code>. So it makes sense for it to visually resemble the Or expression. One minor difference is that in bracket expressions we work with literals and not arbitrary NFAs, so we can simply create a transition for each literal from the start state to the end state.</li>
<li>The image is the visualization of the expression: <code>[a-c]</code></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">bracket</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">literals</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">value</span>.(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">uint8</span>]<span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">literals</span> { <span style="color:#75715e">// &lt;1&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">start</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">l</span>] = []<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>{<span style="color:#a6e22e">end</span>} <span style="color:#75715e">// &lt;2&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span></code></pre></div><ol>
<li>We go through each literal in the bracket</li>
<li>We add a transition from the <code>start</code> state to the <code>end</code> state.</li>
</ol>
<p>Although in our regex engine, we will not implement a negated bracket expression (<em>where the characher should be non of the specified chars</em>), this is how the Thompson construction would look like:</p>
<p><img src="/unfunction/tokenToNfa_bracket_not.png" alt="bracket negation to nfa"></p>
<ul>
<li><code>*</code> represents any character</li>
<li>This really depends on the way the engine is implemented, but one simple way could be to look for exact matches, if there&rsquo;s none, we could use the any character transition.</li>
<li>By matching the exact characters first, we could simply send the text containing those characters into a dead end, resulting in a non-match.</li>
</ul>
<h4 id="groups">Groups</h4>
<p>To convert a group expression into an NFA, we need to concatenate all the individual NFAs created from the tokens inside the group. We&rsquo;ve already seen how this is done when we covered <code>toNFA</code> function. The code is exactly the same, with different variable names:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// there is no difference between 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// group, groupUncaptured types in our engine
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">group</span>, <span style="color:#a6e22e">groupUncaptured</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">tokens</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">value</span>.([]<span style="color:#a6e22e">token</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">start</span>, <span style="color:#a6e22e">end</span> = <span style="color:#a6e22e">tokenToNfa</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">tokens</span>[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> &lt; len(<span style="color:#a6e22e">tokens</span>); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ts</span>, <span style="color:#a6e22e">te</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tokenToNfa</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">tokens</span>[<span style="color:#a6e22e">i</span>])
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">end</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = append(
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">end</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>], 
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ts</span>,
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">end</span> = <span style="color:#a6e22e">te</span>
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><h4 id="repetition">Repetition</h4>
<p>Out of all the examples we&rsquo;ve covered, understanding repetition might be the most trickiest, thus we&rsquo;ll take it step by step and try to figure out a generalized solution that covers all repetition cases.</p>
<p>In all the examples, we&rsquo;re about to go through, <code>A</code> will represent any NFA.</p>
<p>Let&rsquo;s start with asterisk (Kleene&rsquo;s star), plus and question mark (optional). In each of the three examples below, we&rsquo;ve also specified the corresponding minimum and maximum occurrence requirements.</p>
<p><img src="/unfunction/tokenToNfa_repeat_1.png" alt="repeat 1 to nfa"></p>
<ul>
<li>Each example has an epsilon transition from start state to the start of <code>A</code>, and from the end of <code>A</code> to the end state. This indicates repeating the NFA <code>A</code> exactly once.</li>
<li><code>*</code>, means that <code>A</code> can be skipped or repeated any number of times:
<ul>
<li>For skipping <code>A</code>, we add an epsilon transition from the start state to the end state directly, bypassing <code>A</code> altogether.</li>
<li>For repeating any number of times, we add an epsilon transition from the end state to the start of <code>A</code></li>
</ul>
</li>
<li><code>+</code> means that <code>A</code> must be repeated at least once, and no upper bound is set.
<ul>
<li>To achieve the the minimum occurrence requirement (which is 1), we simply remove the epsilon transtion from the <code>*</code> example. Now there&rsquo;s no way to bypass <code>A</code>.</li>
</ul>
</li>
<li><code>?</code> means that <code>A</code> can either be skipped or it can occur exactly once
<ul>
<li>This is very similar to <code>*</code> example, and we only need to remove the epsilon transition from the end state to the start of <code>A</code>.</li>
</ul>
</li>
<li>Notes:
<ol>
<li>If minimum is 0, add an epsilon transition from start state to the end state</li>
<li>If maximum is infinity, add an epsilon transition from the end state to the start of the <code>A</code>.</li>
</ol>
</li>
</ul>
<p>Next, let&rsquo;s take a look at the case where exact number of repetitions are specified.</p>
<p><img src="/unfunction/tokenToNfa_repeat_2.png" alt="repeat 2 to nfa"></p>
<ul>
<li>We simply concatenate the same NFA <code>A</code> <em>m</em> times.</li>
</ul>
<p>What if the minimum is specified, but the upper bound is the infinity?</p>
<p><img src="/unfunction/tokenToNfa_repeat_3.png" alt="repeat 3 to nfa"></p>
<ul>
<li>We still concatenate the same NFA <code>A</code> <em>m</em> times because that&rsquo;s the minimum amount of times it needs to repeat.</li>
<li>But we also add an epsilon transition from the end state to the start of the final instance of <code>A</code> (<em>remember the second note from above</em>)</li>
</ul>
<p>Now, onto the final case. Both minimum and maximum number of occurrences are specified, and maximum is not infinity.</p>
<p><img src="/unfunction/tokenToNfa_repeat_4.png" alt="repeat 4 to nfa"></p>
<ul>
<li>We know that <code>A</code> needs to repeat <em>m</em> times. This means that we have to concatenate <code>A</code> <em>m</em> times.</li>
<li>The remaining <em>(n-m)</em> repetitions are completely optional. So at any point, after matching the minimum number of repetitions, we should be able to go to the end state.</li>
<li>To achieve the early termination, all we need to do is to add an epsilon transition from the start state of each <code>A</code> instance to the end state.</li>
</ul>
<p>Let&rsquo;s now see how this is actually coded:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">repeat</span>:
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">value</span>.(<span style="color:#a6e22e">repeatPayload</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">min</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> { <span style="color:#75715e">// &lt;1&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">start</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = []<span style="color:#f92672">*</span><span style="color:#a6e22e">state</span>{<span style="color:#a6e22e">end</span>}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">copyCount</span> <span style="color:#66d9ef">int</span> <span style="color:#75715e">// &lt;2&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">max</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">repeatInfinity</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">min</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">copyCount</span> = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">copyCount</span> = <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">min</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">copyCount</span> = <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">max</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">from</span>, <span style="color:#a6e22e">to</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tokenToNfa</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">token</span>) <span style="color:#75715e">// &lt;3&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">start</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = append( <span style="color:#75715e">// &lt;4&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">start</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>], 
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">from</span>,
</span></span><span style="display:flex;"><span>	) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">copyCount</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> { <span style="color:#75715e">// &lt;5&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">s</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tokenToNfa</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">token</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// connect the end of the previous one 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// to the start of this one
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">to</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = append( <span style="color:#75715e">// &lt;6&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">to</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>], 
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">s</span>,
</span></span><span style="display:flex;"><span>		) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// keep track of the previous NFA&#39;s entry and exit states
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">from</span> = <span style="color:#a6e22e">s</span> <span style="color:#75715e">// &lt;7&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">to</span> = <span style="color:#a6e22e">e</span>   <span style="color:#75715e">// &lt;7&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// after the minimum required amount of repetitions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// the rest must be optional, thus we add an 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// epsilon transition to the start of each NFA 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// so that we can skip them if needed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &gt; <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">min</span> { <span style="color:#75715e">// &lt;8&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = append(
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>], 
</span></span><span style="display:flex;"><span>				<span style="color:#a6e22e">end</span>,
</span></span><span style="display:flex;"><span>			)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">to</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = append( <span style="color:#75715e">// &lt;9&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">to</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>], 
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">end</span>,
</span></span><span style="display:flex;"><span>	) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">max</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">repeatInfinity</span> { <span style="color:#75715e">// &lt;10&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">end</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>] = append(
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">end</span>.<span style="color:#a6e22e">transitions</span>[<span style="color:#a6e22e">epsilonChar</span>], 
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">from</span>,
</span></span><span style="display:flex;"><span>		)
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><ol>
<li>From our notes earlier, we know that if minimum is 0, we need to have an epsilon transition from the start state to the end state</li>
<li><code>copyCount</code> is the maximum number of times we need to create an NFA from <code>p.token</code>.
<ul>
<li>if the max is infinity and min is 0, it is 1 because we need to create at least one copy</li>
<li>if the max is infinity and min is non-zero, it is the min value because, we need to repeat it at least <code>p.min</code> times.</li>
<li>if the max is non-infinity, <code>copyCount</code> is whatever the max is.</li>
</ul>
</li>
<li>Just like we did in the group type, we need to concatenate multiple NFAs, so we start by creating the first copy of this NFA.</li>
<li>The start state is connected to the start of this new NFA.</li>
<li>We iterate the remaining amount of times</li>
<li>Actual concatenation step where we connect the end of the previous NFA to the start of the current NFA.</li>
<li>Save the start and end of the current NFA.</li>
<li>Once we have created the minimum required number of NFAs, the rest must be optional. Thus, we add an epsilon transition from the start of each of those new optional NFAs to the end state.</li>
<li>Connect the end of the last NFA, to the end state.</li>
<li>If the upper bound is infinity, add an epsilon transition from the end state to the start of the last NFA.</li>
</ol>
<h2 id="matching">Matching</h2>
<h2 id="references">References</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Thompson%27s_construction">https://en.wikipedia.org/wiki/Thompson%27s_construction</a></li>
<li><a href="https://en.wikipedia.org/wiki/Regular_expression">https://en.wikipedia.org/wiki/Regular_expression</a></li>
<li><a href="https://deniskyashif.com/2019/02/17/implementing-a-regular-expression-engine/">https://deniskyashif.com/2019/02/17/implementing-a-regular-expression-engine/</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions">https://learn.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions</a></li>
<li><a href="https://regex101.com/">https://regex101.com/</a></li>
<li><a href="https://github.com/python/cpython/blob/main/Lib/test/re_tests.py">https://github.com/python/cpython/blob/main/Lib/test/re_tests.py</a></li>
<li><a href="https://blog.cernera.me/converting-regular-expressions-to-postfix-notation-with-the-shunting-yard-algorithm/">https://blog.cernera.me/converting-regular-expressions-to-postfix-notation-with-the-shunting-yard-algorithm/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Shunting_yard_algorithm">https://en.wikipedia.org/wiki/Shunting_yard_algorithm</a></li>
<li><a href="https://gobyexample.com/">https://gobyexample.com/</a></li>
</ul>

</article>

            </div>
        </main>
    </body><script>
    const themeVal = localStorage.getItem("isDark") || document.getElementsByTagName("body")[0].getAttribute("a")
    document.getElementsByTagName("body")[0].setAttribute("a", themeVal)
    const btns = document.getElementsByClassName('theme-switch')
    for (let btn of btns) {
        btn.innerHTML = themeVal === "dark" ? "light" : "dark"
        btn.addEventListener('click', (event) => {
            const theme = localStorage.getItem("isDark") || document.getElementsByTagName("body")[0].getAttribute("a")
            const isDark = theme === "dark"
            document.getElementsByTagName("body")[0].setAttribute("a", isDark ? "light" : "dark")
            localStorage.setItem("isDark", isDark ? "light" : "dark")
            btn.innerHTML = isDark ? "dark" : "light"
        })
    }
</script></html>
