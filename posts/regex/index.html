<!DOCTYPE html>
<html lang="en-us"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="In this article, we&rsquo;ll build a simple regular expression engine that will be able to use [a-zA-Z0–9_]&#43;@[a-zA-Z0–9]&#43;\.[a-zA-Z]{2,} pattern to check for the validity of email addresses. I will use Golang. We&rsquo;ll divide the whole process into 3 sections:
Parsing Building the epsilon-NFA Matching Parsing On its own, a regex string is just that - a string. We need to convert that input into something has a structure. In this section, we&rsquo;ll go over the process of parsing a regex string into tokens.">  

  <title>
    
      How to build a regex engine from scratch
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/unfunction/" />
  
  
  
  <link rel="stylesheet" href="/unfunction/css/main.1512790eb55ef069931f87fb452e614a3d9108d9963433adbd0ab266ef7133d0cfaf13ef7a8dc4c2cf26bfd01a2fed7d5dfa6c53d6478096b7f5b4f47ec7a04e.css" integrity="sha512-FRJ5DrVe8GmTH4f7RS5hSj2RCNmWNDOtvQqyZu9xM9DPrxPveo3Ews8mv9AaL&#43;19XfpsU9ZHgJa39bT0fsegTg==" />
  
</head>
<body a="light">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/unfunction/" style="font-size: large;">home</a>
<button class="theme-switch">dark</button>


<article>
    <p class="post-meta">
        <time datetime="2023-09-28 22:40:33 -0600 -0600">
            2023-09-28
        </time>
    </p>

    <h1>How to build a regex engine from scratch</h1>

    

    <p>In this article, we&rsquo;ll build a simple regular expression engine that will be able to use <code>[a-zA-Z0–9_]+@[a-zA-Z0–9]+\.[a-zA-Z]{2,}</code> pattern to check for the validity of email addresses. I will use Golang. We&rsquo;ll divide the whole process into 3 sections:</p>
<ul>
<li><a href="#parsing">Parsing</a></li>
<li><a href="#building-the-epsilon-nfa">Building the epsilon-NFA</a></li>
<li><a href="#matching">Matching</a></li>
</ul>
<h2 id="parsing">Parsing</h2>
<p>On its own, a regex string is just that - a string. We need to convert that input into something has a structure. In this section, we&rsquo;ll go over the process of parsing a regex string into tokens. 
The core idea when it comes to parsing regex is simple, we will look for the characters that have special meanings such as * + ? () [] {} etc. and will try to create tokens out of those. It&rsquo;ll be more clear once we start writing some code.
Before getting into the parsing algorithm, let&rsquo;s define some structs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">tokenType</span> <span style="color:#66d9ef">uint8</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">group</span>           <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">bracket</span>         <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">or</span>              <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">quantifier</span>      <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">literal</span>         <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">groupUncaptured</span> <span style="color:#a6e22e">tokenType</span> = <span style="color:#66d9ef">iota</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">token</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">tokenType</span> <span style="color:#a6e22e">tokenType</span>
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// the payload required for each token will be different 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">// so we need to be flexible with the type
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">value</span>     <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">parseContext</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span> <span style="color:#75715e">// the index of the character we&#39;re processing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">// in the regex string
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#a6e22e">pos</span>    <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">tokens</span> []<span style="color:#a6e22e">token</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, next is our parsing algorithm</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">regex</span> <span style="color:#66d9ef">string</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">parseContext</span>{
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">pos</span>:    <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">tokens</span>: []<span style="color:#a6e22e">token</span>{},
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span> &lt; len(<span style="color:#a6e22e">regex</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">process</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ctx</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>parseContext object is useful for us to keep track of our current position and save the already parsed tokens. So the basic idea is that we loop through each character and process it until we reach to the end of the regex string. Next, let&rsquo;s take a look at the process method. It&rsquo;s a bit more involved, so let&rsquo;s take it step by step.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">process</span>(<span style="color:#a6e22e">regex</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>]
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">groupCtx</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">parseContext</span>{
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">pos</span>:    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">tokens</span>: []<span style="color:#a6e22e">token</span>{},
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parseGroup</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">groupCtx</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span> = append(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>, <span style="color:#a6e22e">token</span>{
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">group</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">groupCtx</span>.<span style="color:#a6e22e">tokens</span>,
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span> } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;[&#39;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parseBracket</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span> } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;|&#39;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parseOr</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span> } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;*&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;?&#39;</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;+&#39;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parseRepeat</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span> } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;{&#39;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parseRepeatSpecified</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span> } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// literal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">token</span>{
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">literal</span>,
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">ch</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span> = append(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>, <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As we mentioned earlier, we try to match the characters we recognize and use them to parse tokens. Let&rsquo;s take the first if statement. We check if the character is ( - the opening parenthesis. It represents the start of a group. Thus we try to parse the next couple of characters expecting a string of characters that corresponds to a regex group. The same applies to all the other characters specified in conditions above. However, the steps following the match will be different for each character as they have different semantic meanings. Next, we&rsquo;ll examine each of the functions defined in the above snippet. 
Let&rsquo;s actually start from the very bottom because it&rsquo;s the simplest case. If the character is not recognized, then it probably is a literal. Please keep in mind that this is a simplified implementation. There are a lot of cases to consider when it comes to parsing regular expressions; for instance, 1 is a number, but depending on the context it can actually be a part of a backreference \1 that refers to the first captured group. Our simplified algorithm also does not consider the escape characters. 
Next, let&rsquo;s take a look at the parsing of group expressions. This is the implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parseGroup</span>(<span style="color:#a6e22e">regex</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span> <span style="color:#75715e">// get past the LPAREN (
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;)&#39;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">process</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s extremely simple, we process each character like we did in the parse method until we encounter the closing parenthesis. We will not cover the error handling in this tutorial, so we&rsquo;re simply not checking if the index is still within bounds. It will panic anyway. But what about the extra code around parseGroup ? What happens there? Here&rsquo;s the snippet:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">groupCtx</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">parseContext</span>{
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">pos</span>:    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">tokens</span>: []<span style="color:#a6e22e">token</span>{},
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// parsing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">parseGroup</span>(<span style="color:#a6e22e">regex</span>, <span style="color:#a6e22e">groupCtx</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span> = append(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>, <span style="color:#a6e22e">token</span>{
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">group</span>,
</span></span><span style="display:flex;"><span> <span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">groupCtx</span>.<span style="color:#a6e22e">tokens</span>,
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>Basically, we create a new context specific to each group, so that we&rsquo;ll be able to bundle together all the tokens within a specific group without dealing with the top level context object. 
Let&rsquo;s now see how we can parse bracket expressions. This is the whole function, but we&rsquo;ll cover it step by step.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">parseBracket</span>(<span style="color:#a6e22e">regex</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">parseContext</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span> <span style="color:#75715e">// get past the LBRACKET
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">literals</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;]&#39;</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>]
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span> {
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">prev</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">literals</span>[len(<span style="color:#a6e22e">literals</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">literals</span>[len(<span style="color:#a6e22e">literals</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%c%c&#34;</span>, <span style="color:#a6e22e">prev</span>, <span style="color:#a6e22e">next</span>)
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>         <span style="color:#a6e22e">literals</span> = append(<span style="color:#a6e22e">literals</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%c&#34;</span>, <span style="color:#a6e22e">ch</span>))
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">literalsSet</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">uint8</span>]<span style="color:#66d9ef">bool</span>{}
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">literals</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">l</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">literalsSet</span>[<span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">0</span>]] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">0</span>]; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">1</span>]; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">literalsSet</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span> = append(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>, <span style="color:#a6e22e">token</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">bracket</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">literalsSet</span>,
</span></span><span style="display:flex;"><span>   })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Similarly to the way we parsed the group expression, we go through each character till we reach the closing bracket character. For each character we check if it is - because that&rsquo;s the range indicator (e.g., a-zK-Z2-8). If it&rsquo;s not the range indicator we consider it a single literal, and save it to the list.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">literals</span> []<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;]&#39;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ch</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;-&#39;</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">next</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">regex</span>[<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">prev</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">literals</span>[len(<span style="color:#a6e22e">literals</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">literals</span>[len(<span style="color:#a6e22e">literals</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%c%c&#34;</span>, <span style="color:#a6e22e">prev</span>, <span style="color:#a6e22e">next</span>)
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">literals</span> = append(<span style="color:#a6e22e">literals</span>, <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%c&#34;</span>, <span style="color:#a6e22e">ch</span>))
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">pos</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When it is indeed the range indicator, we take the next character from the regex string, and the previous character from the list of literals (it&rsquo;s the last character in that list). Then we save it back to the list as 2 characters together. We could choose a different way of saving the parsed literals, but I find this to be simple and easy to understand.
Moving on, now we have a list of literals and ranges. But those can contain duplicates. Consider the following regex: [a-me-s] . There&rsquo;s a clear overlap between the ranges.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">literalsSet</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">uint8</span>]<span style="color:#66d9ef">bool</span>{}
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">literals</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">l</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">literalsSet</span>[<span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">0</span>]] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">0</span>]; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">1</span>]; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">literalsSet</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>     }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span> = append(<span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">tokens</span>, <span style="color:#a6e22e">token</span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">tokenType</span>: <span style="color:#a6e22e">bracket</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">value</span>:     <span style="color:#a6e22e">literalsSet</span>,
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>This part of the algorithm is pretty simple, we go over the saved values, and check if they are literals or ranges. If ranges we go over each character in the range and add it to the set. By definition, sets do not contain duplicates, so that gets job done. Since we&rsquo;re implementing this in Golang, we are using a map because there are no natively provided sets in Golang, and installing a library just for a set is unnecessary. Finally, once we have all the duplicates removed, we save the bracket token to our list of tokens.</p>
<h2 id="building-the-epsilon-nfa">Building the epsilon-NFA</h2>
<h2 id="matching">Matching</h2>

</article>

            </div>
        </main>
    </body><script>
    const btns = document.getElementsByClassName('theme-switch')
    for (let btn of btns) {
        btn.addEventListener('click', (event) => {
            const isDark = document.getElementsByTagName("body")[0].getAttribute("a") === "dark"
            if (isDark) {
                document.getElementsByTagName("body")[0].setAttribute("a", "light")
                btn.innerHTML = "dark"
            } else {
                document.getElementsByTagName("body")[0].setAttribute("a", "dark")
                btn.innerHTML = "light"
            }
        })
    }
</script></html>
